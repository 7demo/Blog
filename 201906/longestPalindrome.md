# longestPalindrome

> 参考：马拉车算法

马拉车算法需要先明白几个概念：

+ `aba`与`abba`都是回文字符串，区别长度为偶数时，回文中心在中间。因此为了减少复杂度，统一原字符串处理下。`aba`处理成`$#a#b#a#`，`abba`处理成`$#a#b#b#a#`，都是成为奇数长度。

+ 处理后的字符串中的回文字符串的半径减去1就是原字符串中回文字符串的长度；处理后字符串中的回文字符串中间位置减去长度除以2就是原字符串中的回文字符串开始位置。

```javascript
var longestPalindrome = function(a) {
    // 统一处理字符串，加特殊符号
    let t = '$#'
    for (let i = 0; i < a.length; i++) {
        t += a[i]
        t += '#'
    }
    // 生成与处理后字符串t长度一样的数组，数组中每个值为t数组中该索引位置的回文字符串长度。
    let p = Array.from({length: t.length})
    let id = 0 // 达到最右回文字符串的中心位置索引
    let mx = 0 // 达到最右侧位置回文字符串的右边界
    let len = 0 // 最大回文字符串的长度
    let start = 0 // 最大回文字符串的开始位置
    for (let i = 1; i < t.length; i++) {
        // 当前循环的i, 如果小于已达到回文字符串右边界（此时必定i大于id的，因为是获取最右侧回文字符串后继续循环的），
        // 那么以i为中心的回文字符串右侧，要么大于已达到的回文字符串右边界，要么小于已达到的回文字符串右边界（废话）
        // 如果已经出了边界，则从该字符串位置开始一点点左右循环，开始时p[i] = 1
        // 如果没有出边界，则i关于id必存在一个对称回文字符串（因为已经找到了以id为中心的回文字符串，它的最右侧是mx）,2*id - i 就是获取关于id的i的对称点，这个值最小为1（比如s#f走到#时）或者2(#f#走到f时)。2id-1大于2时，都是具有有意义的（非#s#类型）回文字符串时。
        // mx - i如果小于2*id-1，即代表不是回文字符串切将要靠近右边界
        p[i] = mx > i ? Math.min(p[2 * id - i], mx - i) : 1
        // 暴力找回文字符串
        while (t[i + p[i]] == t[i - p[i]]) {
            ++p[i]
        }
        // 当前位置加上回文字符串的长度大于已达到的右边界，则更新
        if (p[i] + i > mx) {
            mx = p[i] + i
            id = i
        }
        // 获取回文字符串的长度与开始位置
        if (p[i] > len) {
            len = p[i] - 1
            start = (i - p[i]) / 2
        }
    }
    return a.substr(start, len)
};
```

(参考)[https://segmentfault.com/a/1190000003914228]