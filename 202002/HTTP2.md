# HTTP2

## http1.1

### 长连接

第一次请求完后，TCP未关闭，第二次连接直接复用TCP，也就省去了TCP连接与SSL的时间。一个TCP连接只有当conction: close和服务端主动关闭时才会关闭。

### 管道技术

准确来说是多个HTTP请求放到一个tcp中一一发送，发送过程中不用等待之前请求的响应。但是由于服务器是按照先后顺序处理的，容易引起“线头阻塞”——第一个请求受阻，后续请求则等待。因此默认都是关闭的。

### 更多请求方法支持

新增options。

### host字段支持

## SPDY协议

`SPDY`是HTTP2协议的前身

## HTTP2

### 多路复用

HTTP2只需要建立一个TCP连接。

    1，単TCP连接，占用资源更少

    2，TCP连接减少，减少了创建连接时间，慢启动时间较少。

### 二进制分帧

在应用层与传输层之间增加一个二进制分帧层，所有消息分为Header Frame与Data Frame，分别包装的是首部信息与body。

二进制解析比较高效。帧组成消息，可以乱序发送，根据帧号组装。

### 头部压缩

HTTP采用专用算法hpack。维护一个首部表，所有请求都会首部字段维护进来，进行新增或者替换，每次请求都只会发送差异数据。

### 服务器推送

针对客户端已经有缓存的现象：

    1，允许客户端通过`RESET_STREAM`来取消服务器推送。

    2，客户端通过`Cache Digest`来告诉客户端哪些已缓存。

HTTP在lunix与ox上还允许TCP在建立链接时就就换数据，这就是TFO——TCP Fast Open。

### 流量控制

客户端与服务器都可以使用`window-update`来控制发送窗口大小。

### 优先级控制

这个可以算伪命题。本质上是限制TCP上某个流的大小，从而避免影响其他数据流，从而更好实现多路复用。


整个问题：如果出现丢包，则整个TCP都会重传。则出现谷歌的QUIC协议。

1，ORTT。缓存会话的上下文，下次恢复时只需验证缓存就可以建立链接。

2，多路复用。因为基于udp, 如果丢包不影响后续传输

3，加密报文

4，向前纠错机制。丢失一个包，通过其他包数据，则不影响。
