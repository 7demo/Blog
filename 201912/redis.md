# redis

### redis与memcache

1，redis的数据类型比较多，memcache只有字符串。

2，操作速度比较快——纯内存操作、单线程避免上下文切换操作、非阻塞异步io。

3，redis持久化，memcache只内存中。redis是memcache的高级版。

4，redis支持数据备份。主从模式-从从模式。

5，限制数据内存占用大小，超过则淘汰一定规则的key。

6, 操作原子性


#### 数据类型

`String/Hash/List/Set/zSet`, `HyperLogLog/Geo/Pub.Sub`, `Redis Module--BloomFilter,RedisSearch,Redis-ml`

#### 分布式锁

用`setnx`抢锁，设置`expire`，可以合成一条指令。

#### 找出N个固定开头的key

用`scan`无阻塞提取，但是会重复，最后做一次去重即可。

#### 异步队列

使用`list`数据结构，使用`rpush`生产消息，使用`lpop`消费消息。没有消息，需要`sleep`。但是可以使用`blpop`，如果么有消息会阻塞等待消息来，而不用`sleep`， 并且`blpop`可以支持多个键，实现分级队列。使用`pub/sub`实现1:N消息队列，缺点就是消费者下线会丢失消息。如果使用延时队列：`sortedset`.

#### 如何实现持久化的

RDB——全量持久化（全量数据）与AOF(操作日志)——增量持久化.  AOF日志可以`sync`，都开`sync`不丢失数据，但是会影响性能。如果不全开启，则丢失的数据看时间，系统默认是为30s。AOF优先级更高。

RDB原理：redis使用`fork`复制一份进程，父进程继续作为客户端工作，子进程是写入数据后进行替换旧数据。


#### 集群

从数据只读，接受来自主数据库的同步。同步过程：主数据进在快照与命令完成后同步给从数据库，由于采用乐观复测策略，所以过程中数据可能不一样，但是最终都是一样的，并且2.6版本以后支持增量传输。

从数据库也可以拥有从数据库。主从模式可以实现读写分离，读从写主。


#### 哨兵

监控主从数据库是否正常工作，自动切换从数据库为主数据库。哨兵会定时向主从服务器发送`info/ping`等命令来监测状态。如果主服务器没响应，则会询问子服务器是否也认为主数据库已下线，进而选择领头的哨兵进行恢复。哨兵节点数量为奇数。


#### 问题

+ 1，缓存穿透，大量请求缓存未命中（创建中），直接请求数据库。方案：

a. 互斥锁排队。获取key为空时，锁上。从数据库获取数据再释放。但是逻辑增加、吞吐量也降低。

b，布隆过滤器。它通过三个hash函数与一个位数组，能快速获得set中的值。不过有误判率。

+ 2，缓存雪崩。缓存同时失效，大量请求落到数据库中。

a. 加锁排队。

b. 备份缓存A与B，A设置超时时间，B不设置超时时间，A不存在读B，则更新缓存。

+ 3，并发
