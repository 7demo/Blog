# V8垃圾回收

> V8是将js转为效率更高的机器码，V8也不是解释器，而是编译器。V8中所有数据是32b字宽进行存储。

## 内存分配

V8在64位系统下最大为1.4G，32为700m。在node中，可以通过`process.memoryUsage()`查看：

```
{ rss: 23584768, // resident set size 所有内存占用
  heapTotal: 9682944, //v8可以分配的最大堆内存
  heapUsed: 5621544, // 已分配的堆内存
  external: 8837 } //c++绑定到js对象上的内存
```

如果想扩大内存使用，就要使用`buffer`。

## 编译器

V8曾有两个编译器，`full-codegen`与`Crankshaft`，第一次执行js时直接利用`full-codegen`生成机器码。运营一段时间后，使用`crankshaft`进行优化。优化点：内联代码、

## V8内存结构

V8主要由两部分组成：`memory heap`与`call stack`, 即内存分配的地址与代码执行的地方。

新生代内存区、老生代内存区、大对象区、代码区（拥有执行权限的内存）、map区（存放cell与map, 每个区域都是存放大小相同的元素）。

## 回收机制

### 如何判断可以被回收

#### 标记清除

标记不在使用的变量，等待被回收。

#### 引用计数

一个变量被创建时引用次数为1，若赋值给其他变量则引用加1，如果一个变量不再引用此值，则引用次数减少1。如果引用次数为0，则可以回收。但是在互相引用的过程中，则无法清除，会造成内存泄漏。

### V8回收策略

V8将内存分为新生代与老生代，分别执行不同的垃圾回收算法。新生代代表存活时间较短的对象，老生代则为存活时间长或者常驻内存。一个对象创建时都在新生代，满足一定条件会移动到老生代，不过若创建时内存不足，则直接分配到老生代。

64位系统下，新生代内存为32m，老生代为1.4G, 32位系统下，新生代内存为16m, 老生代为700m。

新生代将内存一分为二，叫`semispace`，一块使用一块闲置，使用的称为From空间，闲置的称为To空间。使用`Scavenge`进行回收，具体就是从From空间赋值对象到To空间时，只会复制存活的对象（广度优先搜索算法）。

如果多次复制依然存活的对象，则复移动到老生代内存中，这个过程叫晋升。晋升条件：

1，复制过程看是否经历过一次回收

2，如果To空间使用超过25%。

老生代采用标记清楚`Make-sweep`的方式回收。在清楚后会出现内存空间出现不连续的现象，就会触发`Make-compact`。标记完，会把存活对象移动到空间的一端，然后直接清理边界外的内存。

因为老生代回收内存时暂停时间较久，所以是采用增量标记——每次标记分为很多次，每完成一部分，就让程序执行一下，再进行标记。等全部标记后，再进行清理，即延迟清理——lasy-sweeping。

## 性能优化

1, 相同的顺序实例化对象属性

2，动态属性

3，重复一个方法比一次多个方法速度快

4，避免使用稀疏数组

5，标记值。


参考：[聊聊V8引擎的垃圾回收](https://juejin.im/post/5ad3f1156fb9a028b86e78be)
